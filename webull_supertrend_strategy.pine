//@version=5
strategy("Supertrend MTF Inducement Strategy", 
         overlay=true, 
         initial_capital=100000, 
         commission_type=strategy.commission.percent, 
         commission_value=0.01,
         process_orders_on_close=true,
         pyramiding=0)

// ——— Supertrend base settings
atrLen = input.int(10, "ATR Length", minval=1)
stFactor = input.float(3.0, "Supertrend Factor", minval=0.01, step=0.01)

// ——— Timeframe grid (intraday focus)
tf2m = input.timeframe("2", "TF 0 (very fast 2m)")
tf5 = input.timeframe("5", "TF 1 (fast)")
tf15 = input.timeframe("15", "TF 2")
tf30 = input.timeframe("30", "TF 3")
tf60 = input.timeframe("60", "TF 4 (HTF filter)")

minAlign = input.int(2, "Min higher TFs aligned (of TF2/TF3/TF4)", minval=1, maxval=3)

// ——— 2m confirmation controls
use2mConfirm = input.bool(true, "Use 2m Supertrend agreement")
require2mInducement = input.bool(true, "Require 2m inducement confluence")

// ——— Inducement filters (volume + candle shape/size)
volLen = input.int(50, "Volume SMA Length", minval=1)
volMult = input.float(1.5, "Volume Spike x SMA", step=0.1)
bodyAtrMult = input.float(0.9, "Impulsive Body ≥ ATR x", step=0.1)
hammerWickX = input.float(2.5, "Hammer/Shooting-Star Wick ≥ Body x", step=0.1)
hammerOppX = input.float(0.5, "Opposite Wick ≤ Body x", step=0.1)

// ——— Chop / momentum gates
adxLen = input.int(14, "ADX Length", minval=1)
adxMin = input.float(18.0, "Min ADX", step=0.5)
atrPctMin = input.float(0.25, "Min ATR% of Price", step=0.01)
useBreakout = input.bool(true, "Require Breakout (reduce consolidation whipsaws)")
brkLookback = input.int(10, "Breakout Lookback (bars)", minval=1)

// ——— Session filter
sess = input.session("0930-1600", "Session (exchange time)")
inSession = not na(time(timeframe.period, sess))

// ——— Risk / exits
riskPct = input.float(1.0, "Risk % of Equity per Trade", step=0.1)
takeProfitATR = input.float(2.5, "Take Profit (ATR x)", step=0.1)
stopATR = input.float(1.5, "Initial Stop (ATR x)", step=0.1)
trailWithST = input.bool(true, "Trail Stop with Supertrend")

// ——— Cooldown to avoid rapid re-entries in chop
cooldownBars = input.int(5, "Cooldown Bars After Exit", minval=0)

// ——— Supertrend function (manual implementation for compatibility)
f_supertrend(factor, atrPeriod) =>
    hl2_ = (high + low) / 2
    atr_ = ta.atr(atrPeriod)
    upperBand = hl2_ + (factor * atr_)
    lowerBand = hl2_ - (factor * atr_)
    
    var float prevUpperBand = na
    var float prevLowerBand = na
    var int trend = 1
    var float superTrend = na
    
    upperBand := na(prevUpperBand) or close[1] > prevUpperBand ? upperBand : math.min(upperBand, prevUpperBand)
    lowerBand := na(prevLowerBand) or close[1] < prevLowerBand ? lowerBand : math.max(lowerBand, prevLowerBand)
    
    trend := na(trend[1]) ? 1 : close <= lowerBand[1] ? -1 : close >= upperBand[1] ? 1 : trend[1]
    superTrend := trend == 1 ? lowerBand : upperBand
    
    prevUpperBand := upperBand
    prevLowerBand := lowerBand
    
    [superTrend, trend]

// ——— Base-timeframe Supertrend (chart TF)
[stBase, dirBase] = f_supertrend(stFactor, atrLen)
isUp(d) => d > 0
isDn(d) => d < 0

// ——— MTF Supertrends
[st2, d2] = request.security(syminfo.tickerid, tf2m, f_supertrend(stFactor, atrLen))
[st5_, d5] = request.security(syminfo.tickerid, tf5, f_supertrend(stFactor, atrLen))
[st15_, d15] = request.security(syminfo.tickerid, tf15, f_supertrend(stFactor, atrLen))
[st30_, d30] = request.security(syminfo.tickerid, tf30, f_supertrend(stFactor, atrLen))
[st60_, d60] = request.security(syminfo.tickerid, tf60, f_supertrend(stFactor, atrLen))

// ——— Alignment count
alignedUp = (isUp(d15) ? 1 : 0) + (isUp(d30) ? 1 : 0) + (isUp(d60) ? 1 : 0)
alignedDown = (isDn(d15) ? 1 : 0) + (isDn(d30) ? 1 : 0) + (isDn(d60) ? 1 : 0)

// ——— Inducement detection on current bar
atr = ta.atr(atrLen)
volMA = ta.sma(volume, volLen)
volOK = volume > volMA * volMult

body = math.abs(close - open)
barRange = high - low
upW = high - math.max(open, close)
dnW = math.min(open, close) - low

impulseUp = close > open and (body >= bodyAtrMult * atr) and volOK
impulseDown = close < open and (body >= bodyAtrMult * atr) and volOK

bullHammer = (dnW >= hammerWickX * body) and (upW <= hammerOppX * body) and volOK
bearHammer = (upW >= hammerWickX * body) and (dnW <= hammerOppX * body) and volOK

induceLong = impulseUp or bullHammer
induceShort = impulseDown or bearHammer

// ——— 2m inducement
impulseUp2 = request.security(syminfo.tickerid, tf2m, 
    close > open and (math.abs(close - open) >= bodyAtrMult * ta.atr(atrLen)) and (volume > ta.sma(volume, volLen) * volMult))

impulseDown2 = request.security(syminfo.tickerid, tf2m, 
    close < open and (math.abs(close - open) >= bodyAtrMult * ta.atr(atrLen)) and (volume > ta.sma(volume, volLen) * volMult))

bullHammer2 = request.security(syminfo.tickerid, tf2m, 
    ((math.min(open, close) - low) >= hammerWickX * math.abs(close - open)) and 
    ((high - math.max(open, close)) <= hammerOppX * math.abs(close - open)) and 
    (volume > ta.sma(volume, volLen) * volMult))

bearHammer2 = request.security(syminfo.tickerid, tf2m, 
    ((high - math.max(open, close)) >= hammerWickX * math.abs(close - open)) and 
    ((math.min(open, close) - low) <= hammerOppX * math.abs(close - open)) and 
    (volume > ta.sma(volume, volLen) * volMult))

induceLong2 = impulseUp2 or bullHammer2
induceShort2 = impulseDown2 or bearHammer2

fastAgreeOK = not use2mConfirm or (isUp(dirBase) and isUp(d2)) or (isDn(dirBase) and isDn(d2))

// ——— ADX calculation (manual implementation for better compatibility)
f_adx(len) =>
    up = ta.change(high)
    down = -ta.change(low)
    plusDM = na(up) ? na : (up > down and up > 0 ? up : 0)
    minusDM = na(down) ? na : (down > up and down > 0 ? down : 0)
    trur = ta.rma(ta.tr, len)
    plus = fixnan(100 * ta.rma(plusDM, len) / trur)
    minus = fixnan(100 * ta.rma(minusDM, len) / trur)
    sum = plus + minus
    adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), len)
    adx

// ——— Chop filters
adx = f_adx(adxLen)
atrPct = atr / close * 100
momentumOK = (adx >= adxMin) and (atrPct >= atrPctMin)

brkLong = close > ta.highest(high, brkLookback)[1]
brkShort = close < ta.lowest(low, brkLookback)[1]
breakoutOK(dirLong) => not useBreakout or (dirLong ? brkLong : brkShort)

// ——— Flip logic
flipUp = dirBase[1] < 0 and dirBase > 0
flipDown = dirBase[1] > 0 and dirBase < 0

// ——— Cooldown tracking
var int lastExitBar = na
cooldownOK = na(lastExitBar) or (bar_index - lastExitBar >= cooldownBars)

// ——— Entry conditions
longAlignOK = isUp(dirBase) and alignedUp >= minAlign
shortAlignOK = isDn(dirBase) and alignedDown >= minAlign

induceLongAll = induceLong and (not require2mInducement or induceLong2)
induceShortAll = induceShort and (not require2mInducement or induceShort2)

longCond = inSession and cooldownOK and flipUp and longAlignOK and fastAgreeOK and induceLongAll and momentumOK and breakoutOK(true)
shortCond = inSession and cooldownOK and flipDown and shortAlignOK and fastAgreeOK and induceShortAll and momentumOK and breakoutOK(false)

// ——— Sizing
equity = strategy.equity
stopDist = math.max(atr * stopATR, syminfo.mintick)
posValue = equity * (riskPct / 100.0)
qtyFloat = posValue / stopDist
qty = math.max(qtyFloat, 1)

// ——— Orders
if longCond and strategy.position_size <= 0
    strategy.entry("L", strategy.long, qty=qty)

if shortCond and strategy.position_size >= 0
    strategy.entry("S", strategy.short, qty=qty)

// ——— Exits
var float entryPrice = na
if strategy.position_size != 0 and strategy.position_size[1] == 0
    entryPrice := strategy.position_avg_price

tpPriceLong = entryPrice + takeProfitATR * atr
slPriceLong = entryPrice - stopDist
tpPriceShort = entryPrice - takeProfitATR * atr
slPriceShort = entryPrice + stopDist

stStopLong = trailWithST and isUp(dirBase) ? stBase : na
stStopShort = trailWithST and isDn(dirBase) ? stBase : na

finalSLLong = na(stStopLong) ? slPriceLong : math.max(stStopLong, slPriceLong)
finalSLShort = na(stStopShort) ? slPriceShort : math.min(stStopShort, slPriceShort)

if strategy.position_size > 0
    strategy.exit("L-Exit", from_entry="L", stop=finalSLLong, limit=tpPriceLong)
if strategy.position_size < 0
    strategy.exit("S-Exit", from_entry="S", stop=finalSLShort, limit=tpPriceShort)

// Mark bar of exit for cooldown
justClosed = strategy.position_size[1] != 0 and strategy.position_size == 0
if justClosed
    lastExitBar := bar_index

// ——— Visuals
upColor = color.new(color.green, 0)
downColor = color.new(color.red, 0)
fillUpColor = color.new(color.green, 90)
fillDownColor = color.new(color.red, 90)

upPlot = plot(isUp(dirBase) ? stBase : na, "Up Trend", color=upColor, style=plot.style_linebr, linewidth=2)
downPlot = plot(isDn(dirBase) ? stBase : na, "Down Trend", color=downColor, style=plot.style_linebr, linewidth=2)
bodyMid = plot(barstate.isfirst ? na : (open + close) / 2, display=display.none)

fill(bodyMid, upPlot, color=fillUpColor)
fill(bodyMid, downPlot, color=fillDownColor)

// ——— Debug markers
plotshape(longCond, title="Long Entry", style=shape.triangleup, color=upColor, location=location.belowbar, size=size.small, text="L")
plotshape(shortCond, title="Short Entry", style=shape.triangledown, color=downColor, location=location.abovebar, size=size.small, text="S")

// ——— Alerts
alertcondition(longCond, title="Long Entry", message="Long entry signal")
alertcondition(shortCond, title="Short Entry", message="Short entry signal")